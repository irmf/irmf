/*{
  "author": "Glenn M. Lewis",
  "copyright": "Apache-2.0",
  "date": "2019-07-13",
  "irmf": "1.0",
  "materials": ["metal","dielectric"],
  "max": [25,25,61],
  "min": [-25,-25,-61],
  "notes": "The IRMF shader that started it all... the bifilar electromagnet.",
  "options": {},
  "title": "bifilar electromagnet",
  "units": "mm",
  "version": "1.0"
}*/

#define M_PI 3.1415926535897932384626433832795

float coilSquareFace(in mat4 xfm, float radius, float size, float gap, float nTurns, float trimEndAngle, in vec3 xyz) {
  xyz = (vec4(xyz, 1.0) * xfm).xyz;
  
  // First, trivial reject on the two ends of the coil.
  if (xyz.z < -0.5 * size || xyz.z > nTurns * (size + gap) + 0.5 * size) { return 0.0; }
  
  // Then, constrain the coil to the cylinder with wall thickness "size":
  float rxy = length(xyz.xy);
  if (rxy < radius - 0.5 * size || rxy > radius + 0.5 * size) { return 0.0; }
  
  // If the current point is between the coils, return no material:
  float angle = atan(xyz.y, xyz.x) / (2.0 * M_PI);
  if (angle < 0.0) { angle += 1.0; } // 0 <= angle <= 1 between coils
  float dz = mod(xyz.z, size + gap); // 0 <= dz <= (size+gap) between coils.
  
  float lastHelixZ = angle * (size + gap);
  if (lastHelixZ > dz) { lastHelixZ -= (size + gap); }
  float nextHelixZ = lastHelixZ + (size + gap);
  
  if (dz > lastHelixZ + 0.5 * size && dz < nextHelixZ - 0.5 * size) { return 0.0; }
  
  // If the current point is within the start of the first coil, stop it at angle < 0 (angle>0.5 due to wraparound).
  if (xyz.z < 0.5 * size && angle > 0.5) { return 0.0; }
  // If the current point is within the end of the last coil, stop it at angle > PI (angle<0.5 due to wraparound).
  // Additionally, chop off the trimEndAngle. As a result, switch back to radians.
  angle *= 2.0 * M_PI;
  if (xyz.z > nTurns * (size + gap) - 0.5 * size &&
  (angle < M_PI || angle >= 2.0 * M_PI - trimEndAngle)) { return 0.0; }
  
  return 1.0;
}

float box(vec3 start, vec3 end, float size, in vec3 xyz) {
  vec3 ll = min(start, end) - vec3(0.5 * size);
  vec3 ur = max(start, end) + vec3(0.5 * size);
  if (any(lessThan(xyz, ll))|| any(greaterThan(xyz, ur))) { return 0.0; }
  return 1.0;
}

mat3 rotAxis(vec3 axis, float a) {
  // This is from: http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/
  float s = sin(a);
  float c = cos(a);
  float oc = 1.0 - c;
  vec3 as = axis * s;
  mat3 p = mat3(axis.x * axis, axis.y * axis, axis.z * axis);
  mat3 q = mat3(c, - as.z, as.y, as.z, c, - as.x, - as.y, as.x, c);
  return p * oc + q;
}

mat4 rotZ(float angle) {
  return mat4(rotAxis(vec3(0, 0, 1), angle));
}

float wire(vec3 start, vec3 end, float size, in vec3 xyz) {
  vec3 v = end - start;
  float angle = dot(v, vec3(1, 0, 0));
  xyz -= start;
  xyz = (vec4(xyz, 1) * rotZ(angle)).xyz;
  return box(vec3(0), vec3(length(v), 0, 0), size, xyz);
}

float coilPlusConnectorWires(int coilNum, int numCoils, float inc, float innerRadius, float connectorRadius, float size, float gap, float nTurns, in vec3 xyz) {
  float radiusOffset = float(coilNum - 1);
  mat4 xfm = mat4(1) * rotZ(radiusOffset * inc);
  float coilRadius = radiusOffset + innerRadius;
  float trimEndAngle = 2.0 * inc;
  if (coilNum == numCoils) {
    trimEndAngle = inc;
  } else if (coilNum == numCoils - 1) {
    trimEndAngle = 3.0 * inc;
  }
  float coil = coilSquareFace(xfm, coilRadius, size, gap, nTurns, trimEndAngle, xyz);
  
  xyz = (vec4(xyz, 1.0) * xfm).xyz;
  
  float bz = -(size + gap);
  float tz = nTurns * (size + gap);
  float tzp1 = (nTurns + 1.0) * (size + gap);
  
  coil += box(vec3(coilRadius, 0.0, 0.0), vec3(coilRadius, 0.0, bz), size, xyz);
  coil += box(vec3(coilRadius, 0.0, bz), vec3(connectorRadius, 0.0, bz), size, xyz);
  coil += box(vec3(connectorRadius, 0.0, bz), vec3(connectorRadius, 0.0, tzp1), size, xyz);
  
  if (coilNum >= 3) { // Connect the start of this coil to the end of two coils prior.
    float lastCoilRadius = radiusOffset - 2.0 + innerRadius;
    coil += box(vec3(lastCoilRadius, 0.0, tzp1), vec3(connectorRadius, 0.0, tzp1), size, xyz);
    coil += box(vec3(lastCoilRadius, 0.0, tz), vec3(lastCoilRadius, 0.0, tzp1), size, xyz);
  } else if (coilNum == 2) { // Connect the start of 2 to the end of the last odd coil.
    float endOddRadius = float(numCoils - 2) + innerRadius;
    coil += box(vec3(endOddRadius, 0.0, tzp1), vec3(connectorRadius, 0.0, tzp1), size, xyz);
    coil += box(vec3(endOddRadius, 0.0, tz), vec3(endOddRadius, 0.0, tzp1), size, xyz);
  }
  
  return coil;
}

 vec2 bifilarElectromagnet(float size, float gap, float nTurns, in vec3 xyz) {
  if (xyz.z < 120.1) { return vec2(0); } // For debugging ends.
  // if (xyz.z > 0.0) { return vec2(0); }  // For debugging ends.
  
  const int numCoils = 20;
  const float inc = 2.0 * M_PI / float(numCoils);
  const float innerRadius = 3.0;
  float connectorRadius = innerRadius + float(numCoils) * (size + gap);
  
  float coil01 = coilPlusConnectorWires(1, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil02 = coilPlusConnectorWires(2, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil03 = coilPlusConnectorWires(3, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil04 = coilPlusConnectorWires(4, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil05 = coilPlusConnectorWires(5, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil06 = coilPlusConnectorWires(6, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil07 = coilPlusConnectorWires(7, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil08 = coilPlusConnectorWires(8, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil09 = coilPlusConnectorWires(9, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil10 = coilPlusConnectorWires(10, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil11 = coilPlusConnectorWires(11, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil12 = coilPlusConnectorWires(12, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil13 = coilPlusConnectorWires(13, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil14 = coilPlusConnectorWires(14, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil15 = coilPlusConnectorWires(15, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil16 = coilPlusConnectorWires(16, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil17 = coilPlusConnectorWires(17, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil18 = coilPlusConnectorWires(18, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil19 = coilPlusConnectorWires(19, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  float coil20 = coilPlusConnectorWires(20, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  
  float metal = coil01 + coil02 + coil03 + coil04 + coil05 + coil06 +
  coil07 + coil08 + coil09 + coil10 + coil11 + coil12 + coil13 +
  coil14 + coil15 + coil16 + coil17 + coil18 + coil19 + coil20;
  
  float dielectric = 0.0;
  
  return vec2(metal, dielectric);
 }

 void mainModel4(out vec4 materials, in vec3 xyz) {
  xyz.z += 60.0;
  materials.xy = bifilarElectromagnet(0.85, 0.15, 120.0, xyz);
 }
